//! Generated Atomic Data types for {{ name }} ontology
//! 
//! This file was automatically generated using atomic-ontology-generator.
//! Do not edit this file directly.

use serde::{Deserialize, Serialize};
use atomic_lib::{Resource, Store, Storelike};
use anyhow::Result;

{% for class in classes %}
{% for line in class.description | split(pat="\n") %}
/// {{ line | trim }}
{% endfor %}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{ class.name }} {
    {% for prop in class.properties %}
    {% for line in prop.description | split(pat="\n") %}
    /// {{ line | trim }}
    {% endfor %}
    pub {{ prop.name }}: {{ prop.type_name }},
    {% endfor %}
}

impl {{ class.name }} {
    /// Create a new instance from an Atomic Resource
    pub fn from_resource(resource: &Resource, store: &impl Storelike) -> Result<Self> {
        Ok(Self {
            {% for prop in class.properties -%}
            {{ prop.name }}: resource.get_propvals()
                .get("{{ prop.subject }}")
                {%- if prop.required -%}
                .ok_or_else(|| anyhow::anyhow!("Missing required property: {{ prop.name }}"))
                {%- else -%}
                .map(|v| v.to_string())
                .unwrap_or_default()
                {%- endif -%}
                ?.to_string(),
            {% endfor %}
        })
    }
}

{% endfor %}

/// Property URLs for {{ name }}
pub mod properties {
    {% for prop in properties %}
    {% for line in prop.description | split(pat="\n") %}
    /// {{ line | trim }}
    {% endfor %}
    pub const {{ prop.name | upper }}: &str = "{{ prop.subject }}";
    {% endfor %}
}

#[cfg(test)]
mod tests {
    use super::*;
    use atomic_lib::Store;

    {% for class in classes %}
    #[test]
    fn test_{{ class.name | lower | replace(from="-", to="_") }}() -> Result<()> {
        let store = Store::init()?;
        store.populate()?;

        let resource = store.get_resource("{{ class.subject }}")?;
        let instance = {{ class.name }}::from_resource(&resource, &store)?;
        
        {% for prop in class.properties %}
        {% if prop.required %}
        // Test required property {{ prop.name }}
        match instance.{{ prop.name }} {
            {% if prop.type_name == "String" %}
            ref s => assert!(!s.is_empty(), "{{ prop.name }} should not be empty"),
            {% else %}
            _ => (),
            {% endif %}
        }
        {% endif %}
        {% endfor %}
        
        // Test serialization
        let serialized = serde_json::to_string(&instance)?;
        let deserialized: {{ class.name }} = serde_json::from_str(&serialized)?;
        
        {% for prop in class.properties %}
        assert_eq!(instance.{{ prop.name }}, deserialized.{{ prop.name }});
        {% endfor %}
        
        Ok(())
    }

    {% endfor %}
} 