//! Generated Atomic Data types for {{ name }} ontology
//! 
//! This file was automatically generated using atomic-ontology-generator.
//! Do not edit this file directly.

use serde::{Deserialize, Serialize};
use atomic_lib::{
    Resource, Store, Storelike, urls, Value,
    agents::ForAgent,
    collections::{Collection, CollectionBuilder},
};
use anyhow::Result;

{%- for class in classes %}
{%- for line in class.description | split(pat="\n") %}
/// {{ line | trim }}
{%- endfor %}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{ class.name }} {
    {%- for prop in class.properties %}
    {%- for line in prop.description | split(pat="\n") %}
    /// {{ line | trim }}
    {%- endfor %}
    pub {{ prop.name }}: {{ prop.type_name }},
    {%- endfor %}
}

impl {{ class.name }} {
    /// Create a new instance from an Atomic Resource
    pub fn from_resource(resource: &Resource, store: &impl Storelike) -> Result<Self> {
        Ok(Self {
            {%- for prop in class.properties %}
            {{ prop.name }}: {%- if prop.is_array %}
                match store.get_path(&format!("{} {}", resource.get_subject(), "{{ prop.subject }}"), None, &ForAgent::Sudo)? {
                    atomic_lib::storelike::PathReturn::Subject(subjects) => {
                        if subjects.contains(',') {
                            subjects.split(',')
                                .map(|s| s.trim().to_string())
                                .filter(|s| !s.is_empty())
                                .collect()
                        } else {
                            vec![subjects.to_string()]
                        }
                    },
                    atomic_lib::storelike::PathReturn::Atom(atom) => match atom.value {
                        Value::ResourceArray(arr) => arr,
                        Value::String(s) => vec![s],
                        _ => vec![]
                    },
                }
            {%- else %}
                match store.get_path(&format!("{} {}", resource.get_subject(), "{{ prop.subject }}"), None, &ForAgent::Sudo)? {
                    atomic_lib::storelike::PathReturn::Subject(subject) => subject.to_string(),
                    atomic_lib::storelike::PathReturn::Atom(atom) => atom.value.to_string(),
                }
            {%- endif %},
            {%- endfor %}
        })
    }

    /// Fetch all instances of this class using the Collections API
    pub fn get_all_instances(store: &impl Storelike) -> Result<Vec<Self>> {
        let collection = CollectionBuilder::new(store)
            .set_property(urls::IS_A)
            .set_value("{{ class.subject }}")
            .build();

        let mut instances = Vec::new();
        let members: Vec<String> = collection.get_members()?;
        for member in members {
            let resource = store.get_resource(&member)?;
            instances.push(Self::from_resource(&resource, store)?);
        }
        Ok(instances)
    }

    /// Fetch all instances with sorting options
    pub fn get_sorted_instances(
        store: &impl Storelike,
        sort_by: Option<&str>,
        sort_desc: bool,
    ) -> Result<Vec<Self>> {
        let mut builder = CollectionBuilder::new(store)
            .set_property(urls::IS_A)
            .set_value("{{ class.subject }}");

        if let Some(sort_prop) = sort_by {
            builder = builder.set_sort_by(sort_prop).set_sort_desc(sort_desc);
        }

        let collection = builder.build();
        let mut instances = Vec::new();
        let members: Vec<String> = collection.get_members()?;
        for member in members {
            let resource = store.get_resource(&member)?;
            instances.push(Self::from_resource(&resource, store)?);
        }
        Ok(instances)
    }
}
{%- endfor %}

/// Property URLs for {{ name }}
pub mod properties {
    {%- for prop in properties %}
    {%- for line in prop.description | split(pat="\n") %}
    /// {{ line | trim }}
    {%- endfor %}
    pub const {{ prop.name | upper }}: &str = "{{ prop.subject }}";
    {%- endfor %}
}

#[cfg(test)]
mod tests {
    use super::*;
    use atomic_lib::Store;

    {%- for class in classes %}
    #[test]
    fn test_{{ class.name | lower | replace(from="-", to="_") }}() -> Result<()> {
        let store = Store::init()?;
        store.populate()?;

        let resource = store.get_resource("{{ class.subject }}")?;
        let instance = {{ class.name }}::from_resource(&resource, &store)?;
        
        {%- for prop in class.properties %}
        {%- if prop.required %}
        // Test required property {{ prop.name }}
        {%- if prop.is_array %}
        assert!(!instance.{{ prop.name }}.is_empty(), "{{ prop.name }} array should not be empty");
        {%- else %}
        assert!(!instance.{{ prop.name }}.is_empty(), "{{ prop.name }} should not be empty");
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        
        // Test serialization
        let serialized = serde_json::to_string(&instance)?;
        let deserialized: {{ class.name }} = serde_json::from_str(&serialized)?;
        
        {%- for prop in class.properties %}
        assert_eq!(instance.{{ prop.name }}, deserialized.{{ prop.name }});
        {%- endfor %}
        
        Ok(())
    }
    {%- endfor %}

    {%- for class in classes %}
    #[tokio::test]
    async fn test_{{ class.name | lower | replace(from="-", to="_") }}_instances() -> Result<()> {
        let store = Store::init()?;
        store.populate()?;

        // Test fetching all instances
        let instances = {{ class.name }}::get_all_instances(&store)?;
        for instance in instances {
            {%- for prop in class.properties %}
            {%- if prop.required %}
            assert!(!instance.{{ prop.name }}.is_empty(), "{{ prop.name }} should not be empty");
            {%- endif %}
            {%- endfor %}
        }

        // Test fetching sorted instances
        {%- for prop in class.properties %}
        let sorted_instances = {{ class.name }}::get_sorted_instances(
            &store,
            Some("{{ prop.subject }}"),
            false
        )?;
        assert!(sorted_instances.len() >= 0);
        {%- endfor %}

        Ok(())
    }
    {%- endfor %}
} 